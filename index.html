
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Calculadora de vencimiento</title>
    <link rel="stylesheet" href="styles.css">
  <style>
    /* ===== Switcher (segmentado) mínimo, no invasivo ===== */
    .segmented {
      display: inline-flex;
      border: 1px solid var(--border, #e5e7eb);
      border-radius: 10px;
      overflow: hidden;
      background: color-mix(in oklab, var(--card-bg, #fff) 90%, var(--bg, #f7f9fc));
    }
    .segmented .seg-btn {
      padding: 8px 14px;
      border: none;
      background: transparent;
      color: var(--text, #101318);
      cursor: pointer;
      font: inherit;
      transition: background .15s ease, color .15s ease;
    }
    .segmented .seg-btn + .seg-btn { border-left: 1px solid var(--border, #e5e7eb); }
    .segmented .seg-btn.active {
      background: color-mix(in oklab, var(--primary, #2563eb) 16%, var(--bg, #f7f9fc));
      color: #fff;
    }
    /* Ocultar bloques según modo */
    .hidden { display: none !important; }
  </style>
</head>

<body>
  <h1>Calculadora de vencimiento (2 campos)</h1>
  <p class="muted">
    Ingresa la <b>fecha/hora</b> de creación y, si corresponde, las <b>horas de vida</b> del ticket.
    Jornada por defecto: <b>Lun–Vie, 08:00–19:00</b> (Lima, UTC−5).
  </p>

  <div class="card" role="region" aria-label="Calculadora de vencimiento">
    <!-- 1) Fecha/hora -->
    <div class="row">
      <div>
        <label for="dt"><b>Fecha/hora de creación</b></label>
        <div style="display:flex; gap:8px;">
          <input id="dt" type="text" placeholder="Ej: 2025-12-29 08:56:13" aria-describedby="dtHelp" style="flex:1;">
          <button id="nowBtn" type="button" class="btn secondary" title="Usar ahora (Lima)">Ahora</button>
        </div>
        <small id="dtHelp" class="muted">
          Formatos admitidos: <code>YYYY-MM-DD HH:mm[:ss]</code>, <code>YYYY/MM/DD HH:mm[:ss]</code>,
          <code>DD/MM/YYYY HH:mm[:ss]</code>, o <code>YYYY-MM-DDTHH:mm</code>.
        </small>
      </div>

      <!-- 2) Switcher de modo -->
      <div>
        <label><b>Modo de ingreso de horas</b></label>
        <div class="segmented" role="tablist" aria-label="Modo de ingreso">
          <button type="button" class="seg-btn active" data-mode="manual" aria-selected="true" aria-controls="manualBlock">Manual</button>
          <button type="button" class="seg-btn" data-mode="lookup" aria-selected="false" aria-controls="lookupBlock">Por Palabra Clave</button>
        </div>
        <small class="muted">Alterna entre ingreso manual o selección por Palabra Clave (usa OLA interna).</small>
      </div>
    </div>

    <!-- 3) Bloque MANUAL (visible por defecto) -->
    <div id="manualBlock" class="row" style="margin-top:12px;">
      <div>
        <label for="hours"><b>Horas de vida del ticket</b></label>
        <input id="hours" type="number" min="0" step="0.25" placeholder="48" aria-describedby="hHelp">
        <small id="hHelp" class="muted">Usa decimales si necesitas (ej. <code>12.5</code>).</small>
      </div>
    </div>

    <!-- 4) Bloque LOOKUP (oculto inicialmente) -->
    <div id="lookupBlock" class="row hidden" style="margin-top:12px;">
      <div>
        <label for="keywordFilter">Filtrar Palabra Clave</label>
        <input id="keywordFilter" type="text" placeholder="Escribe para filtrar (ej: Cloud, Adobe, Notebook)"/>
        <small>Filtra la lista según texto.</small>
      </div>
      <div>
        <label for="keywordSelect">Palabra Clave</label>
        <select id="keywordSelect" size="10" aria-describedby="lookupHelp"></select>
        <small id="lookupHelp" class="muted">Al seleccionar, se aplica su OLA automáticamente.</small>
      </div>
      <div style="grid-column: 1 / -1;">
        <label>Detalle del seleccionado</label>
        <div id="lookupInfo" class="result" style="display:none;"></div>
      </div>
    </div>

    <!-- 5) Acciones -->
    <div style="margin-top:16px; display:flex; gap:8px; justify-content:center;">
      <button id="calcBtn" class="btn">Calcular vencimiento</button>
      <button id="resetBtn" class="btn secondary">Restablecer ejemplo</button>
    </div>

    <!-- 6) Resultado -->
    <div id="result" class="result" style="display:none;" aria-live="polite"></div>
    <div id="tools" class="tools" style="display:none;">
      <button id="copyBtn" class="btn secondary">Copiar</button>
    </div>

    <!-- 7) Detalle del cálculo -->
    <details style="margin-top:12px;">
      <summary><b>Detalle del cálculo</b> (tramos acumulados)</summary>
      <pre id="debugLog"></pre>
    </details>

    <!-- 8) Configuración avanzada (después del resultado) -->
    <details style="margin-top:12px;">
      <summary><b>Configuración avanzada</b> (horario, días hábiles, feriados, pausa)</summary>
      <div class="row" style="margin-top:8px;">
        <div>
          <label for="workStart">Inicio de jornada</label>
          <input id="workStart" type="time" value="08:00">
        </div>
        <div>
          <label for="workEnd">Fin de jornada</label>
          <input id="workEnd" type="time" value="19:00">
        </div>
        <div>
          <label>Días hábiles</label><br/>
          <small class="muted">Lun–Vie por defecto; incluye Sáb/Dom si aplica.</small>
          <div style="display:flex; gap:8px; margin-top:6px;">
            <label><input type="checkbox" class="wd" value="1" checked> Lun</label>
            <label><input type="checkbox" class="wd" value="2" checked> Mar</label>
            <label><input type="checkbox" class="wd" value="3" checked> Mié</label>
            <label><input type="checkbox" class="wd" value="4" checked> Jue</label>
            <label><input type="checkbox" class="wd" value="5" checked> Vie</label>
            <label><input type="checkbox" class="wd" value="6"> Sáb</label>
            <label><input type="checkbox" class="wd" value="0"> Dom</label>
          </div>
        </div>
        <div>
          <label><input type="checkbox" id="useBreak"> Considerar pausa (ej. 13:00–14:00)</label>
          <div class="row" style="margin-top:6px;">
            <div>
              <label for="breakStart">Inicio de pausa</label>
              <input id="breakStart" type="time" value="13:00">
            </div>
            <div>
              <label for="breakEnd">Fin de pausa</label>
              <input id="breakEnd" type="time" value="14:00">
            </div>
          </div>
        </div>
        <div style="grid-column:1 / -1;">
          <label for="holidays">Feriados (YYYY-MM-DD, uno por línea)</label>
          <textarea id="holidays" rows="6" placeholder="2026-01-01&#10;2025-12-25"></textarea>
        </div>
      </div>
    </details>
  </div>

  <p class="muted" style="margin-top:12px;">
    Notas:
    <br/>• Puedes pegar fechas como <code>2025-12-23 11:20:59</code>, <code>23/12/2025 11:20</code> o <code>2025/12/23 11:20</code>.
    <br/>• Si la hora inicial está fuera del horario laboral, se mueve al próximo inicio de jornada.
    <br/>• Lima (UTC-5) no usa horario de verano; este cálculo es estable durante el año.
    <br/>• Creado por Piero Valverde - Pier0VC
  </p>

  <script>
    // ====== Utilidades de fecha/hora ======
    const pad2 = (n) => String(n).padStart(2,'0');
    const fmtYMDHMS = (d) => `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`;
    const fmtPeru   = (d) => `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${d.getFullYear()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
    const timeToMinutes = (t) => { const [h,m] = t.split(':').map(Number); return h*60 + m; };

    // Parser robusto
    function parseFlexibleDateTime(input) {
      if (!input) return null;
      const s = String(input).replace(/\u00A0/g, ' ').replace(/\s+/g, ' ').trim();

      // ISO / espacio: YYYY-MM-DD[ T]HH:mm[:ss]
      let m = s.match(/^(\d{4})-(\d{2})-(\d{2})T :(\d{2})(?::(\d{2}))?$/);
      if (m) {
        const [_, Y, M, D, h, mm, ss] = m;
        return new Date(+Y, +M-1, +D, +h, +mm, +(ss||0), 0);
      }
      // YYYY/MM/DD HH:mm[:ss] o YYYY-MM-DD HH:mm[:ss]
      m = s.match(/^(\d{4})-\/[-\/](\d{2):(\d{2})(?::(\d{2}))?$/);
      if (m) {
        const [_, Y, M, D, h, mm, ss] = m;
        return new Date(+Y, +M-1, +D, +h, +mm, +(ss||0), 0);
      }
      // DD/MM/YYYY HH:mm[:ss]
      m = s.match(/^(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2})(?::(\d{2}))?$/);
      if (m) {
        const [_, D, M, Y, h, mm, ss] = m;
        return new Date(+Y, +M-1, +D, +h, +mm, +(ss||0), 0);
      }
      // Fallback exacto
      if (/^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}$/.test(s)) {
        const [datePart, timePart] = s.split(' ');
        const [Y, M, D] = datePart.split('-').map(Number);
        const [h, mm, ss] = timePart.split(':').map(Number);
        return new Date(Y, M - 1, D, h, mm, ss, 0);
      }
      return null;
    }

    // “Ahora” en Lima
    function nowInTimeZoneComponents(tz = 'America/Lima') {
      const fmt = new Intl.DateTimeFormat('es-PE', {
        timeZone: tz, year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
      });
      const parts = fmt.formatToParts(new Date());
      const get = (type) => parts.find(p => p.type === type)?.value;
      return { Y:get('year'), M:get('month'), D:get('day'), h:get('hour'), m:get('minute'), s:get('second') };
    }
    function formatYMDHMS({ Y, M, D, h, m, s }) {
      return `${Y}-${M}-${D} ${h}:${m}:${s}`;
    }

    // Calendario laboral
    function isWorkingDay(date, workDaysSet, holidaysSet) {
      const dow = date.getDay();
      const ymd = `${date.getFullYear()}-${pad2(date.getMonth()+1)}-${pad2(date.getDate())}`;
      if (!workDaysSet.has(dow)) return false;
      if (holidaysSet.has(ymd)) return false;
      return true;
    }
    function advanceToNextWorkingDay(date, workDaysSet, holidaysSet) {
      while (!isWorkingDay(date, workDaysSet, holidaysSet)) date.setDate(date.getDate()+1);
    }
    function clampToWorkWindow(date, wsMin, weMin, workDaysSet, holidaysSet) {
      const minutes = date.getHours()*60 + date.getMinutes();
      if (!isWorkingDay(date, workDaysSet, holidaysSet) || minutes < wsMin || minutes >= weMin) {
        do { date.setDate(date.getDate() + (!isWorkingDay(date, workDaysSet, holidaysSet) || minutes >= weMin ? 1 : 0)); }
        while (!isWorkingDay(date, workDaysSet, holidaysSet));
        date.setHours(Math.floor(wsMin/60), wsMin%60, 0, 0);
      }
    }

    // Pausa opcional
    function getDaySegments(wsMin, weMin, useBreak, bStartMin, bEndMin) {
      if (!useBreak) return [[wsMin, weMin]];
      const bStart = Math.max(wsMin, Math.min(bStartMin, weMin));
      const bEnd   = Math.max(wsMin, Math.min(bEndMin, weMin));
      if (bEnd <= bStart) return [[wsMin, weMin]];
      const segs = [];
      if (bStart > wsMin) segs.push([wsMin, bStart]);
      if (bEnd < weMin) segs.push([bEnd, weMin]);
      return segs.length ? segs : [[wsMin, weMin]];
    }
    function findSegment(segs, minutesNow) {
      for (let i=0;i<segs.length;i++){
        const [s,e] = segs[i];
        if (minutesNow < e) return [i, Math.max(minutesNow, s)];
      }
      return [-1,null];
    }

    // Suma de horas laborales
    function addWorkingHours(startDate, hoursToAdd, workStart, workEnd, workDaysArray, holidaysArray, useBreak, breakStart, breakEnd, debug=false) {
      const debugLines = [];
      const wsMin = timeToMinutes(workStart);
      const weMin = timeToMinutes(workEnd);
      const bStartMin = timeToMinutes(breakStart);
      const bEndMin   = timeToMinutes(breakEnd);
      if (weMin <= wsMin) throw new Error("Fin de jornada debe ser posterior al inicio.");
      if (hoursToAdd < 0) throw new Error("Las horas a sumar deben ser ≥ 0.");
      if (!workDaysArray.length) throw new Error("Selecciona al menos un día hábil.");

      const workDaysSet = new Set(workDaysArray.map(Number));
      const holidaysSet = new Set(holidaysArray.map(s=>s.trim()).filter(Boolean));

      const current = new Date(startDate.getTime());
      advanceToNextWorkingDay(current, workDaysSet, holidaysSet);
      clampToWorkWindow(current, wsMin, weMin, workDaysSet, holidaysSet);

      let remaining = Math.round(hoursToAdd * 60);

      while (remaining > 0) {
        if (!isWorkingDay(current, workDaysSet, holidaysSet)) {
          debug && debugLines.push(`No hábil/feriado: ${fmtYMDHMS(current)} → se avanza`);
          advanceToNextWorkingDay(current, workDaysSet, holidaysSet);
          current.setHours(Math.floor(wsMin/60), wsMin%60, 0, 0);
          continue;
        }
        const minutesNow = current.getHours()*60 + current.getMinutes();
        const segsBase = getDaySegments(wsMin, weMin, useBreak, bStartMin, bEndMin);
        const [segIndex, startInSeg] = findSegment(segsBase, minutesNow);

        if (segIndex === -1) {
          current.setDate(current.getDate()+1);
          advanceToNextWorkingDay(current, workDaysSet, holidaysSet);
          current.setHours(Math.floor(wsMin/60), wsMin%60, 0, 0);
          continue;
        }

        const [segStart, segEnd] = segsBase[segIndex];
        const avail = segEnd - startInSeg;
        const chunk = Math.min(remaining, avail);

        const before = new Date(current.getTime());
        current.setHours(Math.floor(startInSeg/60), startInSeg%60, 0, 0);
        current.setMinutes(current.getMinutes() + chunk);
        remaining -= chunk;
        debug && debugLines.push(`+${chunk} min: ${fmtYMDHMS(before)} → ${fmtYMDHMS(current)} (restan ${remaining} min)`);

        if (remaining > 0 && (current.getHours()*60 + current.getMinutes()) >= segEnd) {
          const nextSegIndex = segIndex + 1;
          if (nextSegIndex < segsBase.length) {
            const [nsStart] = segsBase[nextSegIndex];
            current.setHours(Math.floor(nsStart/60), nsStart%60, 0, 0);
          } else {
            current.setDate(current.getDate()+1);
            advanceToNextWorkingDay(current, workDaysSet, holidaysSet);
            current.setHours(Math.floor(wsMin/60), wsMin%60, 0, 0);
          }
        }
      }
      return { end: current, debug: debugLines.join('\n') };
    }

    // ====== UI ======
    const dtEl      = document.getElementById('dt');
    const hoursEl   = document.getElementById('hours');
    const calcBtn   = document.getElementById('calcBtn');
    const resetBtn  = document.getElementById('resetBtn');
    const nowBtn    = document.getElementById('nowBtn');
    const resultEl  = document.getElementById('result');
    const toolsEl   = document.getElementById('tools');
    const debugEl   = document.getElementById('debugLog');

    const workStartEl = document.getElementById('workStart');
    const workEndEl   = document.getElementById('workEnd');
    const holidaysEl  = document.getElementById('holidays');
    const useBreakEl  = document.getElementById('useBreak');
    const breakStartEl= document.getElementById('breakStart');
    const breakEndEl  = document.getElementById('breakEnd');
    const wdChecks    = Array.from(document.querySelectorAll('.wd'));

    // Switcher
    const segBtns = Array.from(document.querySelectorAll('.segmented .seg-btn'));
    const manualBlockEl = document.getElementById('manualBlock');
    const lookupBlockEl = document.getElementById('lookupBlock');
    let currentMode = 'manual';

    function setMode(mode){
      currentMode = mode;
      segBtns.forEach(btn => {
        const isActive = btn.dataset.mode === mode;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
      });
      // Mostrar/ocultar bloques
      manualBlockEl.classList.toggle('hidden', mode !== 'manual');
      lookupBlockEl.classList.toggle('hidden', mode !== 'lookup');
      // Control de edición de horas
      hoursEl.readOnly = (mode === 'lookup');
      hoursEl.placeholder = (mode === 'lookup') ? 'Se llena según Palabra Clave' : '48';
      if (mode === 'lookup') {
        // Si hay seleccionado, actualizar horas
        const opt = keywordSelectEl.selectedOptions[0];
        if (opt) hoursEl.value = String(Number(opt.dataset.hours || '0'));
      }
    }
    segBtns.forEach(btn => btn.addEventListener('click', () => setMode(btn.dataset.mode)));

    // Lista OLA
    const keywordFilterEl= document.getElementById('keywordFilter');
    const keywordSelectEl= document.getElementById('keywordSelect');
    const lookupInfoEl   = document.getElementById('lookupInfo');

    const OLA_SCENARIOS = [
      { keyword: 'ABBYY License',                 ola: '2 Hrs' },
      { keyword: 'Adobe Acrobat License',         ola: '2 Hrs' },
      { keyword: 'Adobe Creative Cloud License',  ola: '2 Hrs' },
      { keyword: 'Alteryx License',               ola: '2 Hrs' },
      { keyword: 'Cloud PC New',                  ola: '4 Hrs' },
      { keyword: 'ChatPwC License',               ola: '2 Hrs' },
      { keyword: 'Data Snipper License',          ola: '2 Hrs' },
      { keyword: 'External Monitor',              ola: '2 Hrs' },
      { keyword: 'ASSET Internal Documentation',  ola: '4 Hrs' },
      { keyword: 'Inventory Management',          ola: '24 Hrs' },
      { keyword: 'Joiner',                        ola: '72 Hrs' },
      { keyword: 'Leave of Absence',              ola: '24 Hrs' },
      { keyword: 'Leaver',                        ola: '12 Hrs' },
      { keyword: 'Mentimeter License',            ola: '2 Hrs' },
      { keyword: 'Copilot License',               ola: '2 Hrs' },
      { keyword: 'Mover',                         ola: '24 Hrs' },
      { keyword: 'Mural License',                 ola: '2 Hrs' },
      { keyword: 'Inventory Audit',               ola: '2 Hrs' },
      { keyword: 'Notebook Maintenance',          ola: '2 Hrs' },
      { keyword: 'Notebook Warranty',             ola: '72 Hrs' },
      { keyword: 'Notebook Inventory',            ola: '48 Hrs' },
      { keyword: 'Notebook Refresh',              ola: '48 Hrs' },
      { keyword: 'Notebook Replace',              ola: '48 Hrs' },
      { keyword: 'Notebook Sale',                 ola: '48 Hrs' },
      { keyword: 'Power Automate License',        ola: '2 Hrs' },
      { keyword: 'Shutterstock License',          ola: '2 Hrs' },
      { keyword: 'Snagit License',                ola: '2 Hrs' },
      { keyword: 'Thinkcell License',             ola: '2 Hrs' }
    ];

    const olaMap = new Map();
    const hoursFromLabel = (label) => Number(String(label).replace(',', '.').replace(/[^\d.]/g,''));

    function initPreloadedOLA() {
      olaMap.clear();
      for (const r of OLA_SCENARIOS) olaMap.set(r.keyword, { hours: hoursFromLabel(r.ola) });
      populateKeywordSelect();
    }
    function populateKeywordSelect() {
      const filter = (keywordFilterEl.value || '').toLowerCase();
      keywordSelectEl.innerHTML = '';
      const items = Array.from(olaMap.entries())
        .map(([k,v]) => ({ keyword: k, hours: v.hours }))
        .sort((a,b) => a.keyword.localeCompare(b.keyword));
      for (const it of items) {
        if (filter && !it.keyword.toLowerCase().includes(filter)) continue;
        const opt = document.createElement('option');
        opt.value = it.keyword;
        opt.textContent = `${it.keyword} · OLA: ${it.hours}h`;
        opt.dataset.hours = String(it.hours);
        keywordSelectEl.appendChild(opt);
      }
    }
    keywordFilterEl.addEventListener('input', populateKeywordSelect);

    keywordSelectEl.addEventListener('change', () => {
      const opt = keywordSelectEl.selectedOptions[0];
      if (!opt) return;
      const h = Number(opt.dataset.hours || '0');
      hoursEl.value = String(h); // se usa internamente (readOnly en lookup)
      lookupInfoEl.style.display = 'block';
      lookupInfoEl.innerHTML = `
        <div><b>Seleccionado:</b> ${opt.value}</div>
        <div><small>OLA aplicado: ${h} horas</small></div>
      `;
    });

    // Helpers
    function getSelectedWorkDays(){ return wdChecks.filter(c => c.checked).map(c => Number(c.value)); }
    function parseHolidaysTextarea(){ return holidaysEl.value.split('\n').map(s => s.trim()).filter(Boolean); }

    function getEffectiveHours() {
      if (currentMode === 'lookup') {
        const opt = keywordSelectEl.selectedOptions[0];
        if (opt) return Number(opt.dataset.hours || '0');
        throw new Error("Selecciona una Palabra Clave o cambia a modo Manual.");
      }
      const hours = parseFloat((hoursEl.value || '').trim());
      if (!Number.isFinite(hours) || hours < 0) throw new Error("Horas inválidas. Ingresa un número ≥ 0.");
      return hours;
    }

    function calculate() {
      try {
        const dateStr = (dtEl.value || '').replace(/\u00A0/g, ' ').trim();
        const startDate = parseFlexibleDateTime(dateStr);
        if (!startDate) throw new Error("Fecha/hora inválida. Usa, por ejemplo: 2025-12-29 08:56:13");

        const hours = getEffectiveHours();

        const workStart = workStartEl.value || "08:00";
        const workEnd   = workEndEl.value   || "19:00";
        const workDays  = getSelectedWorkDays();
        const holidays  = parseHolidaysTextarea();
        const useBreak  = !!useBreakEl.checked;
        const breakStart= breakStartEl.value || "13:00";
        const breakEnd  = breakEndEl.value   || "14:00";

        const { end, debug } = addWorkingHours(
          startDate, hours, workStart, workEnd, workDays, holidays, useBreak, breakStart, breakEnd, true
        );

        resultEl.style.display = 'block';
        toolsEl.style.display = 'flex';
        resultEl.innerHTML = `
          <div><b>Vence:</b> ${fmtPeru(end)} <small>(${fmtYMDHMS(end)})</small></div>
          <div><small>Inicio: ${fmtPeru(startDate)} | Horas: ${hours}${currentMode==='lookup' ? ' (OLA)' : ''}</small></div>
          <div><small>Config: ${workStart}–${workEnd}${useBreak ? ` (pausa ${breakStart}–${breakEnd})` : ''}, días hábiles: ${workDays.join(', ') || '(ninguno)'}, feriados: ${holidays.length}</small></div>
        `;
        debugEl.textContent = debug;
      } catch (err) {
        resultEl.style.display = 'block';
        toolsEl.style.display = 'none';
        resultEl.innerHTML = `<span class="error"><b>Error:</b> ${err.message}</span>`;
        debugEl.textContent = '';
      }
    }

    async function copyResult() {
      const text = resultEl.textContent.trim();
      try { await navigator.clipboard.writeText(text); this.textContent='Copiado ✓'; setTimeout(()=> this.textContent='Copiar', 1200); } catch {}
    }

    function resetExample() {
      dtEl.value    = "2025-12-29 08:56:13";
      hoursEl.value = "48";
      holidaysEl.value = [
        "2026-01-01","2025-12-25","2025-12-08","2025-11-01","2025-10-08",
        "2025-08-30","2025-07-29","2025-07-28","2025-06-29","2025-05-01",
        "2025-04-18","2025-04-17","2025-01-01"
      ].join('\n');
      wdChecks.forEach(c => c.checked = ['1','2','3','4','5'].includes(c.value)); // Lun–Vie
      useBreakEl.checked = false;

      // Modo por defecto: Manual
      setMode('manual');

      // Pre-cargar OLA y limpiar filtros
      initPreloadedOLA();
      keywordFilterEl.value = '';
      populateKeywordSelect();
      lookupInfoEl.style.display = 'none';
      lookupInfoEl.textContent = '';

      resultEl.style.display = 'none';
      toolsEl.style.display  = 'none';
      debugEl.textContent = '';
    }

    function setNowLimaAndMaybeCalculate(autoCalc = true) {
      const comps = nowInTimeZoneComponents('America/Lima');
      const stamp = formatYMDHMS(comps);
      dtEl.value = stamp;
      if (autoCalc) {
        if (currentMode === 'manual' && (!hoursEl.value || !hoursEl.value.trim())) hoursEl.value = '48';
        calculate();
      }
    }

    document.getElementById('copyBtn').addEventListener('click', copyResult);
    calcBtn.addEventListener('click', calculate);
    resetBtn.addEventListener('click', resetExample);
    nowBtn.addEventListener('click', () => setNowLimaAndMaybeCalculate(true));

    // Inicializa
    resetExample();
  </script>
</body>
</html>

